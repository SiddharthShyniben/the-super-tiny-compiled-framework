/*
 *
 * TTTTTTTTTTTTTTTTTTTTTTThhhhhhh
 * T:::::::::::::::::::::Th:::::h
 * T:::::::::::::::::::::Th:::::h
 * T:::::TT:::::::TT:::::Th:::::h
 * TTTTTT  T:::::T  TTTTTT h::::h hhhhh           eeeeeeeeeeee
 *         T:::::T         h::::hh:::::hhh      ee::::::::::::ee
 *         T:::::T         h::::::::::::::hh   e::::::eeeee:::::ee
 *         T:::::T         h:::::::hhh::::::h e::::::e     e:::::e
 *         T:::::T         h::::::h   h::::::he:::::::eeeee::::::e
 *         T:::::T         h:::::h     h:::::he:::::::::::::::::e
 *         T:::::T         h:::::h     h:::::he::::::eeeeeeeeeee
 *         T:::::T         h:::::h     h:::::he:::::::e
 *       TT:::::::TT       h:::::h     h:::::he::::::::e
 *       T:::::::::T       h:::::h     h:::::h e::::::::eeeeeeee
 *       T:::::::::T       h:::::h     h:::::h  ee:::::::::::::e
 *       TTTTTTTTTTT       hhhhhhh     hhhhhhh    eeeeeeeeeeeeee
 *
 *
 *
 *    SSSSSSSSSSSSSSS
 *  SS:::::::::::::::S
 * S:::::SSSSSS::::::S
 * S:::::S     SSSSSSS
 * S:::::S            uuuuuu    uuuuuu ppppp   ppppppppp       eeeeeeeeeeee    rrrrr   rrrrrrrrr
 * S:::::S            u::::u    u::::u p::::ppp:::::::::p    ee::::::::::::ee  r::::rrr:::::::::r
 *  S::::SSSS         u::::u    u::::u p:::::::::::::::::p  e::::::eeeee:::::eer:::::::::::::::::r
 *   SS::::::SSSSS    u::::u    u::::u pp::::::ppppp::::::pe::::::e     e:::::err::::::rrrrr::::::r
 *     SSS::::::::SS  u::::u    u::::u  p:::::p     p:::::pe:::::::eeeee::::::e r:::::r     r:::::r
 *        SSSSSS::::S u::::u    u::::u  p:::::p     p:::::pe:::::::::::::::::e  r:::::r     rrrrrrr
 *             S:::::Su::::u    u::::u  p:::::p     p:::::pe::::::eeeeeeeeeee   r:::::r
 *             S:::::Su:::::uuuu:::::u  p:::::p    p::::::pe:::::::e            r:::::r
 * SSSSSSS     S:::::Su:::::::::::::::uup:::::ppppp:::::::pe::::::::e           r:::::r
 * S::::::SSSSSS:::::S u:::::::::::::::up::::::::::::::::p  e::::::::eeeeeeee   r:::::r
 * S:::::::::::::::SS   uu::::::::uu:::up::::::::::::::pp    ee:::::::::::::e   r:::::r
 *  SSSSSSSSSSSSSSS       uuuuuuuu  uuuup::::::pppppppp        eeeeeeeeeeeeee   rrrrrrr
 *                                      p:::::p
 *                                      p:::::p
 *                                     p:::::::p
 * TTTTTTTTTTTTTTTTTTTTTTT  iiii       p:::::::p
 * T:::::::::::::::::::::T i::::i      p:::::::p
 * T:::::::::::::::::::::T  iiii       ppppppppp
 * T:::::TT:::::::TT:::::T
 * TTTTTT  T:::::T  TTTTTTiiiiiiinnnn  nnnnnnnn yyyyyyy           yyyyyyy
 *         T:::::T        i:::::in:::nn::::::::nny:::::y         y:::::y
 *         T:::::T         i::::in::::::::::::::nny:::::y       y:::::y
 *         T:::::T         i::::inn:::::::::::::::ny:::::y     y:::::y
 *         T:::::T         i::::i  n:::::nnnn:::::n y:::::y   y:::::y
 *         T:::::T         i::::i  n::::n    n::::n  y:::::y y:::::y
 *         T:::::T         i::::i  n::::n    n::::n   y:::::y:::::y
 *         T:::::T         i::::i  n::::n    n::::n    y:::::::::y
 *       TT:::::::TT      i::::::i n::::n    n::::n     y:::::::y
 *       T:::::::::T      i::::::i n::::n    n::::n      y:::::y
 *       T:::::::::T      i::::::i n::::n    n::::n     y:::::y
 *       TTTTTTTTTTT      iiiiiiii nnnnnn    nnnnnn    y:::::y
 *                                                    y:::::y
 *                                                   y:::::y
 *                                                  y:::::y
 *         CCCCCCCCCCCCC                           y:::::y                             iiii  lllllll                                 d::::::d
 *      CCC::::::::::::C                           yyyyyyy                            i::::i l:::::l                                 d::::::d
 *    CC:::::::::::::::C                                                               iiii  l:::::l                                 d::::::d
 *   C:::::CCCCCCCC::::C                                                                     l:::::l                                 d:::::d
 *  C:::::C       CCCCCC   ooooooooooo      mmmmmmm    mmmmmmm   ppppp   ppppppppp   iiiiiii  l::::l     eeeeeeeeeeee        ddddddddd:::::d
 * C:::::C               oo:::::::::::oo  mm:::::::m  m:::::::mm p::::ppp:::::::::p  i:::::i  l::::l   ee::::::::::::ee    dd::::::::::::::d
 * C:::::C              o:::::::::::::::om::::::::::mm::::::::::mp:::::::::::::::::p  i::::i  l::::l  e::::::eeeee:::::ee d::::::::::::::::d
 * C:::::C              o:::::ooooo:::::om::::::::::::::::::::::mpp::::::ppppp::::::p i::::i  l::::l e::::::e     e:::::ed:::::::ddddd:::::d
 * C:::::C              o::::o     o::::om:::::mmm::::::mmm:::::m p:::::p     p:::::p i::::i  l::::l e:::::::eeeee::::::ed::::::d    d:::::d
 * C:::::C              o::::o     o::::om::::m   m::::m   m::::m p:::::p     p:::::p i::::i  l::::l e:::::::::::::::::e d:::::d     d:::::d
 * C:::::C              o::::o     o::::om::::m   m::::m   m::::m p:::::p     p:::::p i::::i  l::::l e::::::eeeeeeeeeee  d:::::d     d:::::d
 *  C:::::C       CCCCCCo::::o     o::::om::::m   m::::m   m::::m p:::::p    p::::::p i::::i  l::::l e:::::::e           d:::::d     d:::::d
 *   C:::::CCCCCCCC::::Co:::::ooooo:::::om::::m   m::::m   m::::m p:::::ppppp:::::::pi::::::il::::::le::::::::e          d::::::ddddd::::::dd
 *    CC:::::::::::::::Co:::::::::::::::om::::m   m::::m   m::::m p::::::::::::::::p i::::::il::::::l e::::::::eeeeeeee   d:::::::::::::::::d
 *      CCC::::::::::::C oo:::::::::::oo m::::m   m::::m   m::::m p::::::::::::::pp  i::::::il::::::l  ee:::::::::::::e    d:::::::::ddd::::d
 *         CCCCCCCCCCCCC   ooooooooooo   mmmmmm   mmmmmm   mmmmmm p::::::pppppppp    iiiiiiiillllllll    eeeeeeeeeeeeee     ddddddddd   ddddd
 *                                                                p:::::p
 *                                                                p:::::p
 *                                                               p:::::::p
 * FFFFFFFFFFFFFFFFFFFFFF                                        p:::::::p                                                                                                        kkkkkkkk
 * F::::::::::::::::::::F                                        p:::::::p                                                                                                        k::::::k
 * F::::::::::::::::::::F                                        ppppppppp                                                                                                        k::::::k
 * FF::::::FFFFFFFFF::::F                                                                                                                                                         k::::::k
 *   F:::::F       FFFFFFrrrrr   rrrrrrrrr   aaaaaaaaaaaaa      mmmmmmm    mmmmmmm       eeeeeeeeeeee  wwwwwww           wwwww           wwwwwww ooooooooooo   rrrrr   rrrrrrrrr   k:::::k    kkkkkkk
 *   F:::::F             r::::rrr:::::::::r  a::::::::::::a   mm:::::::m  m:::::::mm   ee::::::::::::ee w:::::w         w:::::w         w:::::woo:::::::::::oo r::::rrr:::::::::r  k:::::k   k:::::k
 *   F::::::FFFFFFFFFF   r:::::::::::::::::r aaaaaaaaa:::::a m::::::::::mm::::::::::m e::::::eeeee:::::eew:::::w       w:::::::w       w:::::wo:::::::::::::::or:::::::::::::::::r k:::::k  k:::::k
 *   F:::::::::::::::F   rr::::::rrrrr::::::r         a::::a m::::::::::::::::::::::me::::::e     e:::::e w:::::w     w:::::::::w     w:::::w o:::::ooooo:::::orr::::::rrrrr::::::rk:::::k k:::::k
 *   F:::::::::::::::F    r:::::r     r:::::r  aaaaaaa:::::a m:::::mmm::::::mmm:::::me:::::::eeeee::::::e  w:::::w   w:::::w:::::w   w:::::w  o::::o     o::::o r:::::r     r:::::rk::::::k:::::k
 *   F::::::FFFFFFFFFF    r:::::r     rrrrrrraa::::::::::::a m::::m   m::::m   m::::me:::::::::::::::::e    w:::::w w:::::w w:::::w w:::::w   o::::o     o::::o r:::::r     rrrrrrrk:::::::::::k
 *   F:::::F              r:::::r           a::::aaaa::::::a m::::m   m::::m   m::::me::::::eeeeeeeeeee      w:::::w:::::w   w:::::w:::::w    o::::o     o::::o r:::::r            k:::::::::::k
 *   F:::::F              r:::::r          a::::a    a:::::a m::::m   m::::m   m::::me:::::::e                w:::::::::w     w:::::::::w     o::::o     o::::o r:::::r            k::::::k:::::k
 * FF:::::::FF            r:::::r          a::::a    a:::::a m::::m   m::::m   m::::me::::::::e                w:::::::w       w:::::::w      o:::::ooooo:::::o r:::::r           k::::::k k:::::k
 * F::::::::FF            r:::::r          a:::::aaaa::::::a m::::m   m::::m   m::::m e::::::::eeeeeeee         w:::::w         w:::::w       o:::::::::::::::o r:::::r           k::::::k  k:::::k
 * F::::::::FF            r:::::r           a::::::::::aa:::am::::m   m::::m   m::::m  ee:::::::::::::e          w:::w           w:::w         oo:::::::::::oo  r:::::r           k::::::k   k:::::k
 * FFFFFFFFFFF            rrrrrrr            aaaaaaaaaa  aaaammmmmm   mmmmmm   mmmmmm    eeeeeeeeeeeeee           www             www            ooooooooooo    rrrrrrr           kkkkkkkk    kkkkkkk
 *
 * ==================================================================================================================================================================================================
 * ==================================================================================================================================================================================================
 * ==================================================================================================================================================================================================
 * ==================================================================================================================================================================================================
 */

/*
 * Today we're going to write a tiny compiled framework together. A teeny tiny
 * one, in about 600 lines if you removed all the comments from this file, but
 * powerful enough to implement most of the core features of a mature compiled
 * framework like Svelte!
 *
 * We're going to support all the basic features you'd see in a simple Svelte
 * program. Here's what a sample program in our language, which we'll be calling
 * Sleek, would look like:
 *
 *	<script>
 *		import Hello from 'hello.sleek';
 *
 *		const name = 'world';
 *		let count = 0;
 *
 *		function getColor(name) {
 *			return '#' + name.replace(/[^abcdef]/g, "0").padEnd(6, "0")
 *		}
 *
 *		let style = "color: " + getColor(name);
 *
 *		function increment() {
 *			count = count + 1
 *		}
 *
 *		let seconds = 0;
 *		let mins = seconds / 60;
 *		setInterval(() => seconds++, 1000)
 *	</script>
 *
 *	<Hello></Hello>
 *	<p {style}>You have been here for {seconds} seconds ({mins} minutes), and you clicked the button {count} times</p>
 *
 *	<button onclick="increment()">Increment!</button>
 *
 *	<style>
 *		* {
 *			color: red;
 *		}
 *	</style>
 *
 * And Hello.sleek looks like this:
 *	<h1>Hello</h1>
 *
 *	<style>
 *	* {
 *		color: blue;
 *	}
 *	</style>
 *
 * This program gives us a pretty good list of what features we're going to
 * build today:
 *
 * - First and foremost, we write put our markup, styles and JS in the same
 *   file.
 * - We can import other sleek files to include in our code, allowing support
 *   for reusable components and letting us break down our applications into
 *   simpler bits. We include these other components using their names as HTML
 *   tags. In our implementation, we can't pass props or such yet.
 * - In our markup, we can bind variables putting it in {}. Attributes can be
 *   binded using shorthand. These variables will be updated automatically when
 *   they are changed - there's no need to manually update them!
 * - All code in one component is scoped - ie, styles or scripts from one
 *   component won't leak to another. In our example, we see `* {color: red}`
 *   and `* {color: blue}` only apply to their individual components. The same
 *   applies to the JavaScript code too.
 *
 * This is by no means a exhaustive or even minimal list, but it is good enough
 * to teach you all the main moving parts of a project like this. I hope this
 * program educates the next generation of innovators pushing the boundaries of
 * what our browers can perform, helps you understand what is going on under the
 * hood, and generally improves your programming skills. There's something to
 * learn for everyone even if you have no intentions to build your own
 * framework!
 */

/*
 * A compiled framework usually has to do these four things:
 *
 * 1. **Split** the code into individual buckets.
 * 2. **Resolve** all imports and such and add the necessary code to each section.
 * 3. Make sure that none of the pieces of code overlap by **scoping** them.
 * 4. Encode all the bindings in the code and sprinkle in **reactivity**
 */

/*
 * Splitting
 * ---------
 *
 * This step is pretty simple - you just need to extract the HTML, CSS, and JS
 * from the code inputted and deal with them individually.
 *
 * To work with code, mainly the JavaScript, we need to use structures called
 * Abstract Syntax Trees or ASTs. They are symbolic representations of a program.
 * Let's take this program for an example
 *
 *	let sum = 0;
 *	for (let i in [1, 2, 3]) sum += i
 *
 * Here's what the AST for this JavaScript program would look like:
 *
 * - Program
 *   - VariableDeclaration
 *   - ForInStatement
 *		- Left: VariableDeclaration
 *		- Right: ArrayExpression
 *		- Body: ExpressionStatement
 *		  - AssigmentExpression
 *
 * We'll be using three libraries to deal with the ASTs for each language:
 * parse5 for HTML, css for, well, CSS, and recast for JS
 */

/*
 * Resolving
 * ---------
 *
 * Once we’ve split the code into its buckets, the next job is to resolve imports
 * and bring all the pieces together. This step is about making sure every part
 * of the program knows what it needs to know and where to find it.
 *
 * Let’s say our main program imports `Hello.sleek`. We need to:
 *
 * 1. Read `Hello.sleek` and split its contents into HTML, CSS, and JS.
 * 2. Integrate its styles and markup into the calling program, while keeping
 *    things scoped
 * 3. Replace `<Hello/>` in the main program with the resolved markup from
 *    `Hello.sleek`.
 */

/*
 * Scoping
 * -------
 *
 * Next, we scope everything. This step keeps styles from one component isolated
 * from others. Think of it as fencing off each piece to avoid a mess.
 *
 * For the JavaScript, things are pretty simple. If `Hello.sleek` defines
 * functions or variables, we must make sure they don’t interfere with the main
 * program. This can be solved by putting each component in it's own block -
 *
 * Example:
 *
 * Input:
 *
 *	<script>
 *		import Hello from 'hello.sleek';
 *		const name = 'world';
 *	</script>
 *
 * Resolved:
 *
 * {
 *		const name = "dev";
 *		alert("Hello " + name)
 * }
 * const name = 'world';
 *
 * This resolution ensures `Hello` is a self-contained module that won’t leak
 * anything into the global scope.
 *
 * -----------------------------------------------------------------------------
 *
 * Each component’s styles should only apply to its HTML.
 * To achieve this, we automatically add unique class names or data attributes
 * to all elements and rewrite the CSS selectors.
 *
 * Example:
 *
 * Input CSS (from `Hello.sleek`):
 *
 *	* {
 *		color: blue;
 *	}
 *
 * Input HTML (from `Hello.sleek`):
 *
 *	<h1>Hello</h1>
 *
 * Transformed CSS:
 *
 *	*[sleek-hello-uniqueid] {
 *		color: blue;
 *	}
 *
 * Transformed HTML:
 *
 *	<h1 sleek-hello-uniqueid>Hello</h1>
 *
 * This approach makes styles component-specific without requiring manual effort.
 */

/*
 * Reactivity
 * ----------
 *
 * Reactivity is the magic. It’s what makes our variables and DOM stay in sync.
 * When `count` changes, the button click count updates instantly, without manual DOM fiddling.
 *
 * Here’s the plan:
 *
 * 1. Find all the variables that we bind to the DOM.
 * 2. Whenever those variables are updated, insert code to update the variable
 *    in the DOM.
 *
 * Let’s break it down. For a variable like `count`, we replace:
 *
 * Input:
 *
 *	let count = 0;
 *
 * With:
 *
 *	let count = 0;
 *	function __update__count() {
 *		document.getElementsByClassName("__bind__count")[0].innerText = count;
 *	}
 *
 * We then update the DOM to make sure our changes land in the right place:
 *
 * Input:
 *
 *	<p>{count}</p>
 *
 * Transformed:
 *
 *	<p class="__bind__count"></p>
 *
 * And wherever we find that the `count` variable is updated, we insert a call
 * to `__update__count()`:
 *
 * Input:
 *
 *	function increment() {
 *		count = count + 1;
 *	}
 *
 *	Transformed:
 *
 *	function increment() {
 *		{
 *			count = count + 1;
 *			__update__count();
 *		}
 *	}
 *
 * With this setup, any change to count anywhere in the code will trigger a
 * DOM update, with no intervention from the user! The experience feels almost
 * magical.
 */

/*
 * And there you have it: splitting, resolving, scoping, and reactivity all
 * working together in a cute little framework. Each part builds on the last,
 * creating a foundation for Sleek to shine.
 *
 * Now that you have a general high level overview of how to make a compiled
 * framework, why don't you go make one yourself?
 *
 * Just kidding, that's why I'm here to help :3
 * Let's get started...
 */

/*
 * =============================================================================
 *                                    ◕‿◕✿
 *                                  IMPORTS
 * =============================================================================
 */

/*
 * To help us with our task and a lot of the heavy lifting, we're going to use a
 * few libraries:
 *
 * - Recast: An excellent library that helps with JavaScript processing.
 *   Quoting the library's creator, it eliminates "the brain-wasting tasks, the
 *   tasks that are bottlenecked by keystrokes". This library helps us be
 *   declarative, that is say what to do instead of how to do it.
 * - parse5: An HTML5 parser and serializer that helps us with the HTML ASTs.
 *   Used primarily for splitting and scoping.
 * - css: A library that helps us work with CSS ASTs. Mostly used for scoping.
 * - nanoid: A tiny utility to help generate unique IDs for scoping.
 *
 * We also use the standard library file system and path functions later on. We
 * will import them here.
 */

import { parse as parseJS, print, types, visit } from "recast";
import * as HTMLHandler from "parse5";
import * as CSSHandler from "css";
import { nanoid } from "nanoid";

import { basename, extname } from "node:path";
import { readFileSync } from "node:fs";

const b = types.builders;

/*
 * =============================================================================
 *                                    ◕▽◕✿
 *                                 SPLITTING
 * =============================================================================
 */

/*
 * Starting off with the first and simplest bit, splitting up the code. This part
 * is pretty self explanatory. We're just gonna take an input string, a Sleek
 * file with the HTML, CSS and JavaScript, split them into parts, and then return
 * them separately.
 *
 * If this was our input:
 *	<script>
 *		const x = 42;
 *	</script>
 *	<style>
 *		body { color: red; }
 *	</style>
 *	<div>Hello World</div>
 *
 * We'd output something like this:
 *   HTML: "<div>Hello World</div>"
 *   CSS: "body { color: red; }"
 *   JS: "const x = 42;"
 */

// We start by accepting our input file...
function split(code) {
  // We're going on the assumption that everything that isn't in a <style> or
  // <script> tag is HTML, so we're going to assign the entire code fragment to
  // HTML for now
  let HTML = code;
  let CSS = "";
  let JS = "";

  // Here, we're using a Regular Expression to extract each script tag from our
  // file, and we're going to use the callback function in string.replace() to
  // append each fragment to the `JS` variable
  HTML = HTML.replace(
    // Try inputting this regex in a site like regexr.com to see what exactly it
    // does!
    /<script[\s\S]*?>([\s\S]*?)<\/script>/gi,
    (_match, $1) => {
      // We're adding a few newlines here for safety. Technically, it doesn't
      // really change much, but with JavaScript's weird ruleset on inserting
      // semicolons and such, it doesn't hurt.
      JS += "\n\n" + $1;

      // This signifies that we're replacing the script tag with an empty string.
      return "";
    },
  );

  // We do the same for CSS...
  HTML = HTML.replace(/<style[\s\S]*?>([\s\S]*?)<\/style>/gi, (_match, $1) => {
    CSS += "\n\n" + $1;
    return "";
  });

  // And we're going to trim any extra newlines...
  JS = JS.trim();
  CSS = CSS.trim();
  HTML = HTML.trim();

  // And that's it! Now we can go and return each part individually. Every
  // function after this will have the same return signature - they'll return an
  // object of the type { HTML: string, CSS: string, JS: string }
  return { HTML, CSS, JS };
}

/*
 * =============================================================================
 *                                  ┗(◕‿◕✿)┓
 *                                  SCOPING
 * =============================================================================
 */

/*
 * This function, `scope`, is all about scoping the given `HTML`, `CSS`, and
 * `JS` fragments under a unique identifier. Scoping ensures that each component
 * gets its own namespace and doesn’t interfere with others in the document.
 *
 * Here’s how it works:
 *
 * - We start with inputs: the code parts (HTML, CSS, JS) and a `scopeName`.
 * - A unique identifier (`id`) is generated and prepended with "sleek-".
 * - HTML nodes are modified to add the `id` attribute.
 * - CSS selectors are rewritten to include the `id` so they only apply to the
 *   scoped HTML.
 */

// First, we take our input object containing HTML, CSS, and JS.
// We also generate a default unique scope name if one isn’t provided.
function scope(
  { HTML = "", CSS = "", JS = "" },
  scopeName = nanoid(10).toLowerCase(),
) {
  // We'll create a unique identifier for our current scope, prefixed with "sleek-"
  const id = "sleek-" + scopeName;

  // Now we parse the provided HTML into a manipulable document structure.
  // This library makes our AST manipulation similar to how you would do that in
  // a browser, so this code should be pretty simple to you if you've built a
  // website.
  const document = HTMLHandler.parseFragment(HTML);

  // We need to transform all text nodes into proper elements (e.g., wrap plain
  // text in spans). This ensures a consistent structure for scoping.
  document.childNodes = document.childNodes.map((node) => {
    if (node.nodeName === "#text") {
      // Text nodes are replaced with <span> elements containing the original text.
      node.nodeName = node.tagName = "span";
      node.attrs = [];
      node.namespaceURI = "http://www.w3.org/1999/xhtml";

      // We're going to add in a singular text node inside it, which is just the text
      // we had originally. We also need to set it's parent node properly.
      node.childNodes = [
        {
          nodeName: "#text",
          value: node.value,
          parentNode: node,
        },
      ];

      // Remove the original `value` property since it’s now in a child node.
      delete node.value;
      return node;
    }

    return node; // Leave other nodes unchanged.
  });

  // For non-text nodes (e.g., elements), we add the unique `id` attribute to
  // scope them under the current namespace.
  for (const node of document.childNodes.filter(
    // Nodes which aren't actually elements, like #document, #text, #comment all
    // start with a # symbol. We need to exclude them.
    // Did you know the # is also called an octothorpe?
    (node) => !node.nodeName.startsWith("#"),
  )) {
    // The name of the attribute is the id, and it has no value. This gives us
    // something like <element sleek-uniqueid>Text goes here</element>
    node.attrs.push({ name: id, value: "" });
  }

  // Now we need to convert the tree back into a string, by serializing it.
  HTML = HTMLHandler.serialize(document);

  // Now that we're done with the HTML, we're gonna move to the CSS!
  // We're going to update the selectors in each CSS rule to include the unique
  // scope identifier. This ensures the styles only apply to the scoped HTML
  // elements We only add the scoping to the first level of the element - that's
  // all that's necessary.
  //
  // If our sample CSS looked like this:
  //
  //	[type=text] > span { color: red }
  //	div.main { font-size: 32px }
  //
  // We will output something like this:
  //
  //	[type=text][sleek-uniqueid] > span { color: red }
  //	div.main[sleek-uniqueid] { font-size: 32px }

  // First we parse the CSS into an AST
  const CSSData = CSSHandler.parse(CSS);

  // We iterate over every rule in the stylesheet...
  for (const rule of CSSData.stylesheet.rules) {
    if (rule.selectors) {
      // ...and iterate over every selector in the rule.
      rule.selectors = rule.selectors.map((selector) => {
        // First we split a selector into each of it's levels individually
        const temporary = selector.split(/ (?![^[]*])/g);

        // If the style rule doesn't already have a sleek- selector added to it,
        // we add the selector to the end of the first existing selector
        if (!/\[sleek-[\w-]+?]/g.test(selector)) {
          temporary[0] += `[${id}]`;
        }

        // Now we recombine the selector and replace it
        selector = temporary.join(" ");
        return selector;
      });
    }
  }

  // Now that we're done with the CSS, we can go back and stringify it
  CSS = CSSHandler.stringify(CSSData);

  // We're done! Now we return the scoped HTML and CSS, along with the untouched
  // JavaScript code. We'll be scoping the JavaScript code in the next part, where
  // all the resolution takes place

  return { HTML, CSS, JS };
}

/*
 * =============================================================================
 *                                     >_<✿
 *                                 RESOLUTION
 * =============================================================================
 */

/*
 * Our framework allows us to import other .sleek files and include them,
 * allowing us to make reusable components or simply split the program into
 * manageable chunks. We need to find the inputted files, split and scope them,
 * and then include them in the right places in our existing code.
 */

// As usual we input our HTML, CSS and JavaScript...
function resolve({ HTML = "", CSS = "", JS = "" }) {
  // We're finally going to use the JavaScript AST! First we parse the code into
  // an AST so that we can work with it.
  const ast = parseJS(JS);

  // Runnning a function on every node of an AST recursively is called visiting
  // it. Recast gives us an easy way to visit every instance of a specific type
  // of statement.
  visit(ast, {
    // Here, we need to visit every import declaration and import the file as
    // necessary.
    visitImportDeclaration(path) {
      // An import declaration looks like this:
      //
      //	import Hello from 'hello.sleek'
      //
      // And it's corresponding AST looks like this:
      //
      //	{
      //		type: 'ImportDeclaration',
      //		specifiers: [
      //			{
      //				type: 'ImportDefaultSpecifier',
      //				local: {
      //					type: 'Identifier', name: 'Hello', loc: [Object]
      //				},
      //				loc: [Object]
      //			}
      //		],
      //		source: Literal {
      //			type: 'Literal',
      //			value: 'Hello.sleek',
      //			raw: "'Hello.sleek'",
      //			loc: [Object]
      //		},
      //		loc: [Object]
      //	}
      //
      // Here, we're interested in the source file which we're importing from,
      // and the name by which we're importing, which decides the name of the
      // HTML tag in our code.

      const { name } = path.node.specifiers[0].local;
      const source = path.node.source.value;

      // We're gonna make sure that the file we are importing is indeed a .sleek
      // file, and that the only import is a default import.
      if (extname(source) !== ".sleek")
        throw new Error("Unsupported extension imported: " + extname(source));
      if (path.node.specifiers[0].type !== "ImportDefaultSpecifier")
        throw new Error("Only default importing components are allowed");

      // Now we're gonna create a regular expression to test if the given
      // component is used at all, and if so to replace the tag with the
      // appropriate markup
      const tagRegex = new RegExp(
        // This regex selects all instances of <Tag></Tag> or <Tag />
        `<${name}\s*(.*?)><\/${name}>|<${name}\s*(.*?)\/>`,
        // Replace all instances, and be case insensitive
        "gi",
      );

      if (!tagRegex.test(HTML)) {
        // If the tag isn't used, then we just remove the import statement by
        // replacing it with nothing
        path.replace();

        // Returning false in a visitor tells it to not continue down this node
        // - basically telling it that we're done here, move on to the next
        // statement.
        return false;
      }

      // We're going to use our own tools to split, scope, and recursively
      // resolve the components we're importing
      const {
        HTML: _HTML,
        CSS: _CSS,
        JS: _JS,
      } = resolve(
        scope(
          split(readFileSync(path.node.source.value, "utf8")),
          // We're going to this component it's own unique ID, formed by the
          // name of the file imported and a random 5 letter ID
          basename(path.node.source.value).replace(/\..*$/g, "") +
            "-" +
            nanoid(5),
        ),
      );

      // Now we replace the HTML code at the appropriate places, and append the
      // CSS. We don't need to do anything special to our HTML or CSS
      // since it's already scoped!
      HTML = HTML.replace(tagRegex, _HTML);
      CSS += _CSS;

      // Now we append the JavaScript if necessary
      const embeddedJS = parseJS(_JS).program.body;
      // If the AST is empty, we can just go ahead and remove the import
      // statement. Else, we replace it with a block which contains the code.
      // Putting it in a block (that is, inside {}) puts it in it's own scope
      // where it won't interfere with any other JavaScript code!
      if (embeddedJS.length === 0) path.replace();
      else path.replace(b.blockStatement(parseJS(_JS).program.body));

      return false;
    },
  });

  // We're done! Now we stringify the JavaScript AST and return everything.

  JS = print(ast).code;

  return { HTML, CSS, JS };
}

/*
 * =============================================================================
 *                                     ♥︎‿♥︎✿
 *                                 REACTIVITY
 * =============================================================================
 */

/*
 * Reactivity is at the core of a framework - it helps take the burden of one of
 * the most annoying and delegable tasks away from the user and lets them focus
 * on the raw logic.
 *
 * Our framework only supports the simplest of bindings - you can bind any
 * variable using {}. An example would look like this:
 *
 *	<p>You clicked the button {count} times</p>
 *
 * How would we implement reactivity behind the scenes? We need three important
 * things:
 *
 * - A mechanism to update the bindings when the variable is updated
 * - A way to trigger this mechanism when necessary.
 *
 * A pretty simple solution arises to this problem - for every variable, say `x`,
 * we create a function __update__x() which updates any bindings to x in the
 * HTML with the value of x. Before this, we'll replace any bindings to x in the
 * HTML code, that is any instance of {x}, with a span with the id `__bind__x`.
 * Finally, we'll go over every instance of a variable being updated in the
 * code, and we'll add a call to __update__x() right after it.
 */

// This regular expression is used to check for bindings in the HTML. It will
// match {variable}, but not {{variable}}. It does this by using negative
// lookahead and lookbehind.
const bindingRegex = /(?<!{){([^{}]+)}(?!})/g;

// A simple helper function to help replace any instances of a variable binding
// with a span, which will be used to update that binding.
function resolveBindings(HTML) {
  HTML = HTML.replace(
    bindingRegex,
    (_match, $1) => `<span class='__bind__${$1}'></span>`,
  );

  return HTML;
}

// This piece of code is used in a a tiny optimization in our framework.
// It doesn't give you a massive performance boost, but it serves as a good
// teaching example for optimizations you might build yourselves.
//
// Suppose you have this piece of code:
//
//	<script>
//		const SECONDS_PER_YEAR = 60 * 60 * 24 * 365;
//	</script>
//
//	<p>There are {SECONDS_PER_YEAR} seconds in an year.</p>
//
// Here, we could go through our previous process, setting up our
// __update__SECONDS_PER_DAY(), and our <span class="__bind__SECONDS_PER_DAY"></span>
// and such.
//
// But the best way to do this would be to just directly insert the
// value of the variable in the HTML, since it never actually changes.
//
// We do a naive implementation of this, just `eval`ing the code and replacing
// it directly - which doesn't account for any external code, impure functions
// or other variables in the code. In this sense, it's more of a Rust const than
// a JavaScript one, but it serves as a decent example.
function directlyBind(HTML, variable, value) {
  return HTML.replace(bindingRegex, (match, $1) =>
    $1 === variable ? value : match,
  );
}

// Another self explanatory utility function which checks if a variable has been
// bound in the code
function hasBinding(HTML, variable) {
  return new RegExp(`(?<!{){${variable}}(?!})`, "g").test(HTML);
}

// This function checks if an attribute has been bound to the HTML, by checking
// if the function __bind__attr__variable__ exists.
// It would check for things like `<p {style}></p>`, or `<img {src}>`
function hasAttributeBinding(name) {
  let value = "";

  visit(ast, {
    visitFunctionDeclaration(path) {
      // If we find a function along the lines of __bind__attr__..., then
      // we'll return that value
      if (path.node.id.name.startsWith(`__bind__attr__${name}__`)) {
        value = path.node.id.name;
      }
      // There will never be a nested function we need to look at, so we can go
      // ahead and stop going down this node
      return false;
    },
  });

  // We'll also return the function's name
  return value;
}

// These variables will make sense as we go through the rest of the code, but
// I'll explain their purpose with a small example. Consider this program:
//
//	<script>
//		let style = "color: rgb(" + count + ", 0, 0)";
//		let count = 0;
//
//		function increment() {
//			count += 1
//		}
//	</script>
//
//	<button onclick="increment()" {style}>You've clicked me {count} times</button>
//
// Here, the `style` variable depends on the `count` variable, and so the update
// to count should update style too. This way, we need to track which variables
// depend on which ones, and make sure that everything is updated properly. This
// is actually simpler than it seems, because we don't need to deal with chains
// of updates - they deal with themselves. If the variable A depends on B, which
// depends on C, we just need to write the update relation between A and B, and
// B and C. When C changes, it will trigger the relation between B and C, which
// in turn triggers the one between A and B.
let deps = {};
let depsInverted = false;
let HTML = "";
let ast = {};
const finalReactiveCalls = [];

// Now we come to our main function, which does the actual work here.
function makeReactive({ HTML: HTMLIn, CSS, JS }) {
  // We're going to store the input HTML and our JS AST in global state so that
  // other functions can access it too. Global state is bad practice, avoid
  // this! I just did this to make our tutorial simpler and easier to digest.
  HTML = HTMLIn;
  ast = parseJS(JS);

  // First, we're going to visit all the three things we talked about - places
  // where we declare a variable, and update a variable. We need to look at two
  // different AST nodes for updates - ones where we assign a new value to it,
  // and ones where we increment or decrement or otherwise update a value:
  //
  //	x = "new value"
  //	x += "updated value"
  //
  // These are represented differently in the AST, hence the need for two
  // visitors
  visit(ast, {
    visitUpdateExpression: visitUpdate,
    visitAssignmentExpression: visitAssignment,
    visitVariableDeclaration: visitVariable,
  });

  // In our first pass of variable declarations, we only note down what
  // dependencies each variable has. In our second iteration we're actually
  // going to insert all the necessary code to make reactivity work
  visit(ast, {
    visitVariableDeclaration: secondVisitVariable,
  });

  // Finally, we're going to directly bind all constant values
  visit(ast, {
    visitVariableDeclaration: bindConsts,
  });

  // One more thing - we need to bind the initial values of each variable in the
  // HTML at the start. We do this by calling each of the __update__ functions
  // at the end of the program, which is done here. The array finalReactiveCalls
  // will be populated by another function.
  ast.program.body.push(...finalReactiveCalls);

  // Now, we need to update all the bindings in the HTML, and convert them to
  // the proper <span>s
  HTML = resolveBindings(HTMLIn);

  // You know the drill - stringify the JS, and return everything
  JS = print(ast).code;

  return { HTML, CSS, JS };
}

// This function does the first visit to every variable
function visitVariable(path) {
  // We don't need to make constants reactive because, well, they are constant
  if (path.node.kind === "const") return false;

  // For each variable declaration here...
  for (const declaration of path.node.declarations) {
    // We're going to track all the variables this one depends on.
    deps[declaration.id.name] ??= [];

    // We're going to visit the initial value, find every identifier, and add it
    // to the dependency list. You should be familiar with visiting nodes by
    // now.
    visit(declaration.init, {
      visitIdentifier(path) {
        deps[declaration.id.name].push(path.node.name);
        // This calls tells the visitor to continue looking down the tree and
        // find any more identifiers, to not stop here.
        this.traverse(path);
      },
    });
  }

  return false;
}

// This time, we're going to actually include all the code needed for
// reactivitiy. This one does a lot of the heavy lifting and is a bit complex,
// stick with me now...
function secondVisitVariable(path) {
  // Once more, we ignore constants.
  if (path.node.kind === "const") return false;

  // Right now, we track all the variables a certain variable depends on. `deps`
  // could look something like this:
  //
  //	{
  //		// The variable `user` depends on variables `username` and `age`
  //		user: ["username", "age"],
  //		// The variable `email` depends on the variable `username`
  //		email: ["username"],
  //	}
  //
  // But what we are doing in this function is finding a variable declaration,
  // finding all the variables it depends on, and triggering an update to those
  // variables. So the more convenient structure is actually an inversion of
  // the structure here - we need to track what _other variables depend on a
  // certain variable._ An inverted version would look like this:
  //
  //	{
  //		// The variables `user` and `email` depend on the variable
  //		// `username`, and an update to `username` should trigger an update
  //		// to those variables
  //		username: ["user", "email"],
  //		// The variable `user` depends on the variable `age`, and an update
  //		// to `age` should trigger an update to that variable
  //		age: ["user"]
  //	}
  //
  // Here, we also use the variable depsInverted to make sure we don't
  // accidentally invert it twice, thus undoing the inversion
  if (!depsInverted) {
    deps = invert(deps);
  }

  depsInverted = true;

  // This list tracks all the __update__ functions we need to include in the
  // code. For each variable declaration in the node we're currently visiting,
  // we're going to include one update function
  const reactiveDeclarators = [];

  for (const declaration of path.node.declarations) {
    // This block of code here is used to build a piece of JavaScript code
    // programatically, using functions instead of writing an AST object, which
    // is more typing. It's a bit dense, so I've tried to explain each as best
    // as I can. The variable `b` is an alias to the `builders` variable from
    // recast, which is in turn from the package ast-types
    reactiveDeclarators.push(
      // We're building a function, so we use functionDeclaration
      b.functionDeclaration(
        // The name of the function is __update__{variable name goes here}
        b.identifier(`__update__${declaration.id.name}`),
        // This function takes no parameters
        [],
        // The body of the function is a closed block...
        b.blockStatement([
          // The hasMember() function checks if the variable declaration
          // references any other identifiers. That is, it will return true for
          // `let count = tax + 12` but false for `let count = 0`
          hasMember(declaration)
            ? // If we do have a reference to another variable, we need to
              // update the variable to account for any changes in the other
              // variable. So we just duplicate the assignment again. For our
              // earlier example, this would generate the code
              // `count = tax + 12`, which will account for any changes to the
              // `tax` variable
              b.expressionStatement(
                b.assignmentExpression("=", declaration.id, declaration.init),
              )
            : // If not, we don't add anything
              b.emptyStatement(),

          // If this variable is bound to the DOM...
          hasBinding(HTML, declaration.id.name)
            ? // ...then we add the call to update the value in the DOM.
              buildBinding(declaration.id.name)
            : b.emptyStatement(),

          // If this variable is bound as an attribute...
          hasAttributeBinding(declaration.id.name)
            ? // Then call the function which we use to update the attribute in
              // the DOM
              b.expressionStatement(
                // We use callExpression to define a function call
                b.callExpression(
                  // This is the name of the function...
                  b.identifier(hasAttributeBinding(declaration.id.name)),
                  // and we're passing no parameters to the call, so we give it
                  // an empty array
                  [],
                ),
              )
            : b.emptyStatement(),

          // For each dependency we have for this variable..
          ...(deps[declaration.id.name] || []).map((dep) =>
            // ...we're going to add a call to the respective update
            // function. This triggers a chain reaction which will eventually
            // update every variable which directly or indirectly
            // depends on this on!
            b.expressionStatement(
              b.callExpression(b.identifier(`__update__${dep}`), []),
            ),
          ),
        ]),
      ),
    );

    // Now, we're going to add a call to the update function at the end of
    // the program
    finalReactiveCalls.push(
      b.expressionStatement(
        b.callExpression(b.identifier(`__update__${declaration.id.name}`), []),
      ),
    );
  }

  // We're going to append the functions right here, which we do by replacing
  // the node with the node itself + the functions
  path.replace(path.node, ...reactiveDeclarators);

  // Finally, we can stop traversing down this node so we return false.
  return false;
}

// This function is used to add a call to __update__variable__ everywhere a
// variable is updated
function visitUpdate(path) {
  // We're going to replace the node...
  path.replace(
    // ...with a block statement...
    b.blockStatement([
      // ...whose first statement is the node itself...
      b.expressionStatement(path.node),
      // ...and whose second statement is a call to __update__variable__
      b.expressionStatement(
        b.callExpression(
          b.identifier(`__update__${path.node.argument.name}`),
          [],
        ),
      ),
    ]),
  );
  return false;
}

// The exact same thing, but for assignments. There's only a small difference.
// Can you find it?
function visitAssignment(path) {
  path.replace(
    b.blockStatement([
      b.expressionStatement(path.node),
      b.expressionStatement(
        b.callExpression(b.identifier(`__update__${path.node.left.name}`), []),
      ),
    ]),
  );
  return false;
}

// This is the utility we use to invert our dependency graph. It's pretty self
// explanatory.
function invert(object) {
  const newObject = {};

  for (const key in object) {
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      for (const value of object[key]) {
        newObject[value] = newObject[value] || [];
        newObject[value].push(key);
      }
    }
  }

  return newObject;
}

// This is the utility we use to check whether a variable references another
// variable. It does this by checking for any identifiers in the initialization
// of the variable. It's a bit of a naive way to do this - in the real world, we
// wouldn't want every variable to be reactive and we'd probably introduce some
// syntax to mark a variable as reactive. But it works for Sleek.
function hasMember(declaration) {
  let hasMember = false;
  visit(declaration.init, {
    visitIdentifier() {
      hasMember = true;
      return false;
    },
  });

  return hasMember;
}

// This function is used to directly bind our constants.
function bindConsts(path) {
  // We've already done all our `let`s so we can skip those.
  if (path.node.kind === "let") return false;

  // For every variable declaration, we just use the directlyBind function to
  // bind that variable in the DOM
  for (const declaration of path.node.declarations) {
    HTML = directlyBind(
      HTML,
      declaration.id.name,
      // We're using eval here, which should be ringing alarm bells in your head.
      // It's not the best way to do it - it's probably better to not implement
      // this feature at all if you're going to use eval. And if you don't, you
      // should probably use some VM which will give you the value even when the
      // variable depends on other variables.
      //
      // But then, how do you even know if the program will reach the `const` in
      // finite time? What if the program has an infinite loop right before this
      // `const`? Or more realistically, what if the program has an animation
      // running using `setInterval`? The infamous Halting Problem has made an
      // appearance in a seemingly unrelated matter. A lot of complex programs
      // are like this - you find so many seemingly unrelated problems pop up.
      // But that's a tangent for another day - right now, we have a framework
      // to build!
      eval(print(declaration.init).code),
    );
  }

  return false;
}

// This utility function creates the statement
// `document.getElementsByClassName("__bind__uniqueClass")[0].innerText = name
function buildBinding(name) {
  return b.expressionStatement(
    // We're assigning...
    b.assignmentExpression(
      // > assign
      "=",
      // The LHS is document.getElementsByClassName("...")[0].innerText. But in
      // the tree, it's represented opposite to the way we parse it in our minds.
      // Accessing the `innerText` property of `document.getElementsByClassName("...")[0]`
      // gets first precedence, followed by the acccess of the element at index 0
      // in `document.getElementsByClassName("...")
      b.memberExpression(
        // > .innerText
        b.memberExpression(
          // > [0]
          b.callExpression(
            // > call()
            b.memberExpression(
              // document.getElementsByClassName
              b.identifier("document"),
              b.identifier("getElementsByClassName"),
            ),
            // The only argument we pass is the string literal __bind__variable
            [b.literal("__bind__" + name)],
          ), // < call()
          b.literal(0),
        ), // < [0]
        b.identifier("innerText"),
      ), // < .innerText
      b.identifier(name),
    ), // < assign
  );
}

// There's one more thing we've got left to do - we haven't supported binding
// attributes: things like <img {src} /> or <p {class}></p>
// This function will do that for us
function parseAttributeBindings({ HTML = "", CSS = "", JS = "" }) {
  const parsedHTML = HTMLHandler.parseFragment(HTML);

  // parse5 doesn't exactly provide a visitor in itself. We could use another
  // library for this, but our task is pretty simple so we're going to roll our
  // own recursive visitor to do this!
  function _parse(node) {
    if (
      // We can ignore #comment and #text
      node.nodeName.startsWith("#") &&
      !node.nodeName.startsWith("#document")
    ) {
      return node;
    }

    // We're going to recursively parse the children of this AST node.
    node.childNodes = node.childNodes?.map(_parse);

    // If there are no attributes, we can exit early since there's nothing
    // we have to do!
    if (!node.attrs) {
      return node;
    }

    // For every attribute...
    node.attrs = node.attrs.map((attr) => {
      const { name, value } = attr;

      // The syntax of a bound attribute is {attr}, so we test for that
      if (name.startsWith("{") && name.endsWith("}")) {
        const cleanName = name.slice(1, -1);
        const id = nanoid(5);

        // We're going to make yet another random slug, which we'll add as a
        // class to the tag, and use in our code
        const eventSlug = `handle-${cleanName}-${id}`;

        // I've taken a different approach with inserting our JavaScript code
        // here, just to show you another way it could be done. We could just
        // directly append the code like this, using a string:
        JS +=
          "\n\n" +
          `
function __bind__attr__${cleanName}__${id}() {
	document.getElementsByClassName('${eventSlug}')[0].setAttribute('${cleanName}', ${value || cleanName});
}`.trim();
        // On one hand it does save us a lot of typing - this is way more
        // concise than the whole builder syntax. But on the other hand, this
        // does "feel" very wrong - we could be risking some sort of code
        // injection here. Is code injection a risk in a compiler? I'll let you
        // be the judge of that. In my opinion, doing the other approach feels
        // cleaner and safer. But I'll leave this one here just to show you what
        // other ways we could do things. This framework is a learning project,
        // and the more things I give you to ponder, the better it teaches!

        // Now we're going to replace this attribute with the appropriate class
        return { name: "class", value: eventSlug };
      }

      // If this is a regular ol' attribute, we're just gonna return it
      // back
      return attr;
    });

    // We have one more thing left to do - this process might end up leaving
    // duplicate class attributes, which we need to merge into one. This utility
    // does that
    mergeClass(node);

    return node;
  }

  const out = _parse(parsedHTML);

  HTML = HTMLHandler.serialize(out);

  return { HTML, CSS, JS };
}

// This is our utility to merge class attributes in place.
function mergeClass(node) {
  let className = "";

  // We're going to filter out all the class attributes
  node.attrs = node.attrs.filter((attr) => {
    if (attr.name === "class") {
      className += attr.value + " ";
      return false;
    }
    return true;
  });

  // And then we'll add it back together in one attribute
  if (className.trim())
    node.attrs.push({ name: "class", value: className.trim() });
}

/*
 * And with that, we're finally done with reactivity! Whew, that was big. Time
 * to go get yourself a cup of your favourite beverage, and give yourself a pat
 * on the back for completing the most complex (and final!) part of this
 * program.
 *
 */

/**
 * ============================================================================
 *                                  (✿ ‘ヮ’)
 *                         !!!!!!!!THE PARSER!!!!!!!!
 * ============================================================================
 */

/**
 * FINALLY! Now you get to put everything you did together into one function and finally
 * see all your effort pay off!
 */

function parse(code = "") {
  const splitted = split(code);
  const resolved = resolve(splitted);
  const scoped = scope(resolved);
  const bound = parseAttributeBindings(scoped);
  let { HTML, CSS, JS } = makeReactive(bound);

  // We're going to wrap our HTML in some standard markup
  HTML = `
<!DOCTYPE html>
<html>
<head>
	<meta charset='UTF-8'>
	<title>My app</title>
	<link rel='stylesheet' href='style.css'>
</head>
<body>
${HTML.split("\n")
  .map((line) => "\t" + line)
  .join("\n")}
	<script src='main.js'></script>
</body>
</html>
		`.trim();

  return { HTML, CSS, JS };
}

// We can export all the pieces now...
export { split, resolve, scope, parseAttributeBindings, makeReactive, parse };
